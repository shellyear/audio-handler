#!/usr/bin/env node

const camelcase = require('camelcase')
const { ESLint } = require('eslint')
const fg = require('fast-glob')
const { writeFileSync } = require('fs')
const path = require('path')
const prettier = require('prettier')
const ts = require('typescript')

const { factory } = ts

// to prevent Windows backslashes
function slash(path) {
  const isExtendedLengthPath = /^\\\\\?\\/.test(path)
  const hasNonAscii = /[^\u0000-\u0080]+/.test(path) // eslint-disable-line no-control-regex

  if (isExtendedLengthPath || hasNonAscii) {
    return path
  }

  return path.replace(/\\/g, '/')
}

const Path = path
const projectPath = process.cwd()
const OUTPUT_FILE = Path.join(projectPath, '/src/icons.ts')

// TS code generation based on https://ts-creator.js.org/

async function formatCode(code) {
  const options = await prettier.resolveConfig(projectPath)
  const afterPrettier = prettier.format(code, {
    ...options,
    parser: 'typescript'
  })

  const eslint = new ESLint({ fix: true })
  const results = await eslint.lintText(afterPrettier)
  return String(results[0].output || results[0].source) // return results[0].source if linted output wasn't generated (solve later)
}

function generateCode(code) {
  const resultFile = ts.createSourceFile('someFileName.ts', '', ts.ScriptTarget.Latest, false, ts.ScriptKind.TS)
  const printer = ts.createPrinter({
    newLine: ts.NewLineKind.LineFeed
  })
  return printer.printNode(ts.EmitHint.Unspecified, code, resultFile)
}

// import { ReactComponent as "identifier" } from "path"
function createImport(path, identifier) {
  const el = factory.createImportSpecifier(
    false,
    factory.createIdentifier('ReactComponent'),
    factory.createIdentifier(identifier)
  )
  return factory.createImportDeclaration(
    undefined,
    undefined,
    factory.createImportClause(false, undefined /* default import */, factory.createNamedImports([el])),
    factory.createStringLiteral(path)
  )
}

// export type Icon = keyof typeof Icons
function createTypeExport() {
  return factory.createTypeAliasDeclaration(
    undefined,
    [factory.createModifier(ts.SyntaxKind.ExportKeyword)],
    factory.createIdentifier('Icon'),
    undefined,
    factory.createTypeOperatorNode(
      ts.SyntaxKind.KeyOfKeyword,
      factory.createTypeQueryNode(factory.createIdentifier('Icons'))
    )
  )
}

// export const Icons = { identifier[0], indetifier[1], ... }
function createExportVariable(identifiers) {
  const properties = identifiers.map((identifier) =>
    factory.createShorthandPropertyAssignment(factory.createIdentifier(identifier))
  )

  return factory.createVariableStatement(
    [factory.createModifier(ts.SyntaxKind.ExportKeyword)],
    factory.createVariableDeclarationList(
      [
        ts.createVariableDeclaration(
          factory.createIdentifier('Icons'),
          undefined,
          factory.createObjectLiteralExpression(properties, false)
        )
      ],
      ts.NodeFlags.Const
    )
  )
}

// Iterate over icon files
const iconsPath = slash(Path.join(projectPath, 'src/static/svg'))

const result = fg.sync(`${iconsPath}/*.svg`).reduce(
  (acc, filepath) => {
    const [filename] = Path.basename(filepath).split('.')

    // We need suffix, because 'delete' is not valid variable name
    const importIdentifier = `${camelcase(filename)}Icon`
    const relativePath = slash(Path.relative(Path.join(projectPath, 'src'), filepath))

    const node = createImport(`./${relativePath}`, importIdentifier)

    const code = generateCode(node)

    acc.generated = `${acc.generated}\n${code}`
    acc.identifiers.push(importIdentifier)
    return acc
  },
  {
    generated: '',
    identifiers: []
  }
)

// Glue pieces together
const finalCode = `
// AUTOGENERATED, DO NOT EDIT MANUALLY
// @see tooling/icon-generator
${result.generated}

${generateCode(createExportVariable(result.identifiers))}

${generateCode(createTypeExport())}
`

formatCode(finalCode).then((output) => {
  writeFileSync(OUTPUT_FILE, output)
  process.stdout.write(`Icons have been generated, output file: ${OUTPUT_FILE}`)
})
